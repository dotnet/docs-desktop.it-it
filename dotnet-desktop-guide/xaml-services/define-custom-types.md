---
title: Definizione di tipi personalizzati da usare con i servizi XAML .NET
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: 2af59edfac430a1804cff3ffb0ab34df6b550f0a
ms.sourcegitcommit: 9f6df084c53a3da0ea657ed0d708a72213683084
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 12/09/2020
ms.locfileid: "96969616"
---
# <a name="define-custom-types-for-use-with-net-xaml-services"></a><span data-ttu-id="30a18-102">Definire tipi personalizzati da usare con i servizi XAML .NET</span><span class="sxs-lookup"><span data-stu-id="30a18-102">Define custom types for use with .NET XAML Services</span></span>

<span data-ttu-id="30a18-103">Quando si definiscono tipi personalizzati che sono oggetti business o sono tipi che non hanno una dipendenza da framework specifici, è possibile seguire alcune procedure consigliate per XAML.</span><span class="sxs-lookup"><span data-stu-id="30a18-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="30a18-104">Se si seguono queste procedure, i servizi XAML di .NET e i reader XAML e i writer XAML possono individuare le caratteristiche XAML del tipo e assegnargli la rappresentazione appropriata in un flusso di nodi XAML usando il sistema di tipi XAML.</span><span class="sxs-lookup"><span data-stu-id="30a18-104">If you follow these practices, .NET XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="30a18-105">In questo argomento vengono descritte le procedure consigliate per le definizioni dei tipi, le definizioni dei membri e l'attribuzione di CLR di tipi o membri.</span><span class="sxs-lookup"><span data-stu-id="30a18-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>

## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="30a18-106">Modelli di costruttore e definizioni di tipi per XAML</span><span class="sxs-lookup"><span data-stu-id="30a18-106">Constructor Patterns and Type Definitions for XAML</span></span>

<span data-ttu-id="30a18-107">Per creare un'istanza di come elemento oggetto in XAML, una classe personalizzata deve soddisfare i requisiti seguenti:</span><span class="sxs-lookup"><span data-stu-id="30a18-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>

- <span data-ttu-id="30a18-108">La classe personalizzata deve essere pubblica ed è necessario esporre un costruttore pubblico senza parametri.</span><span class="sxs-lookup"><span data-stu-id="30a18-108">The custom class must be public and must expose a parameterless public constructor.</span></span> <span data-ttu-id="30a18-109">Per alcune note riguardanti le strutture, vedere la sezione seguente.</span><span class="sxs-lookup"><span data-stu-id="30a18-109">(See following section for notes regarding structures.)</span></span>

- <span data-ttu-id="30a18-110">La classe personalizzata non deve essere una classe annidata.</span><span class="sxs-lookup"><span data-stu-id="30a18-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="30a18-111">Il "punto" aggiuntivo nel percorso nome completo rende ambigua la divisione dello spazio dei nomi della classe e interferisce con altre funzionalità XAML come le proprietà associate.</span><span class="sxs-lookup"><span data-stu-id="30a18-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>
<span data-ttu-id="30a18-112">Se è possibile creare un'istanza di un oggetto come elemento oggetto, l'oggetto creato può compilare il form elemento proprietà di qualsiasi proprietà che accetta l'oggetto come tipo sottostante.</span><span class="sxs-lookup"><span data-stu-id="30a18-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>

<span data-ttu-id="30a18-113">È comunque possibile fornire i valori oggetto per i tipi che non soddisfano questi criteri, se si Abilita un convertitore di valori.</span><span class="sxs-lookup"><span data-stu-id="30a18-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="30a18-114">Per altre informazioni, vedere [convertitori di tipi ed estensioni di markup per XAML](type-converters-and-markup-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="30a18-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

### <a name="structures"></a><span data-ttu-id="30a18-115">Strutture</span><span class="sxs-lookup"><span data-stu-id="30a18-115">Structures</span></span>

<span data-ttu-id="30a18-116">Le strutture possono sempre essere costruite in XAML, per definizione CLR.</span><span class="sxs-lookup"><span data-stu-id="30a18-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="30a18-117">Questo perché un compilatore CLR crea in modo implicito un costruttore senza parametri per una struttura.</span><span class="sxs-lookup"><span data-stu-id="30a18-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="30a18-118">Questo costruttore inizializza tutti i valori delle proprietà in base alle impostazioni predefinite.</span><span class="sxs-lookup"><span data-stu-id="30a18-118">This constructor initializes all property values to their defaults.</span></span>

<span data-ttu-id="30a18-119">In alcuni casi, il comportamento di costruzione predefinito per una struttura non è auspicabile.</span><span class="sxs-lookup"><span data-stu-id="30a18-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="30a18-120">Questo potrebbe essere dovuto al fatto che la struttura è progettata per riempire i valori e la funzione concettualmente come un'Unione.</span><span class="sxs-lookup"><span data-stu-id="30a18-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="30a18-121">Come Unione, i valori contenuti possono avere interpretazioni che si escludono a vicenda e pertanto nessuna delle sue proprietà è impostabile.</span><span class="sxs-lookup"><span data-stu-id="30a18-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="30a18-122">Un esempio di tale struttura nel vocabolario WPF è <xref:System.Windows.GridLength> .</span><span class="sxs-lookup"><span data-stu-id="30a18-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="30a18-123">Tali strutture devono implementare un convertitore di tipi in modo che i valori possano essere espressi in formato di attributo, usando le convenzioni di stringa che creano le diverse interpretazioni o modalità dei valori della struttura.</span><span class="sxs-lookup"><span data-stu-id="30a18-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="30a18-124">La struttura deve anche esporre un comportamento simile per la costruzione del codice tramite un costruttore senza parametri.</span><span class="sxs-lookup"><span data-stu-id="30a18-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>

### <a name="interfaces"></a><span data-ttu-id="30a18-125">Interfacce</span><span class="sxs-lookup"><span data-stu-id="30a18-125">Interfaces</span></span>

<span data-ttu-id="30a18-126">Le interfacce possono essere utilizzate come tipi sottostanti di membri.</span><span class="sxs-lookup"><span data-stu-id="30a18-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="30a18-127">Il sistema di tipi XAML controlla l'elenco assegnabile e prevede che l'oggetto fornito come valore possa essere assegnato all'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="30a18-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="30a18-128">Non esiste alcun concetto di come l'interfaccia deve essere presentata come tipo XAML purché un tipo assegnabile pertinente supporti i requisiti di costruzione XAML.</span><span class="sxs-lookup"><span data-stu-id="30a18-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>

### <a name="factory-methods"></a><span data-ttu-id="30a18-129">Metodi Factory</span><span class="sxs-lookup"><span data-stu-id="30a18-129">Factory Methods</span></span>

<span data-ttu-id="30a18-130">I metodi factory sono una funzionalità XAML 2009.</span><span class="sxs-lookup"><span data-stu-id="30a18-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="30a18-131">Modificano il principio XAML che gli oggetti devono avere costruttori senza parametri.</span><span class="sxs-lookup"><span data-stu-id="30a18-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="30a18-132">I metodi factory non sono documentati in questo articolo.</span><span class="sxs-lookup"><span data-stu-id="30a18-132">Factory methods are not documented in this article.</span></span> <span data-ttu-id="30a18-133">Vedere [X:FactoryMethod Directive](xfactorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="30a18-133">See [x:FactoryMethod Directive](xfactorymethod-directive.md).</span></span>

## <a name="enumerations"></a><span data-ttu-id="30a18-134">Enumerazioni</span><span class="sxs-lookup"><span data-stu-id="30a18-134">Enumerations</span></span>

<span data-ttu-id="30a18-135">Le enumerazioni hanno un comportamento di conversione di tipi nativi XAML.</span><span class="sxs-lookup"><span data-stu-id="30a18-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="30a18-136">I nomi delle costanti di enumerazione specificati in XAML vengono risolti rispetto al tipo di enumerazione sottostante e restituiscono il valore di enumerazione a un writer di oggetti XAML.</span><span class="sxs-lookup"><span data-stu-id="30a18-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>

<span data-ttu-id="30a18-137">XAML supporta l'utilizzo in stile flag per le enumerazioni con <xref:System.FlagsAttribute> applicato.</span><span class="sxs-lookup"><span data-stu-id="30a18-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="30a18-138">Per altre informazioni, vedere [sintassi XAML in dettaglio](../framework/wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="30a18-138">For more information, see [XAML Syntax In Detail](../framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="30a18-139">La[sintassi XAML](../framework/wpf/advanced/xaml-syntax-in-detail.md) viene scritta per i destinatari WPF, ma la maggior parte delle informazioni contenute in questo argomento è pertinente per XAML che non è specifico di un particolare framework di implementazione.</span><span class="sxs-lookup"><span data-stu-id="30a18-139">([XAML Syntax In Detail](../framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>

## <a name="member-definitions"></a><span data-ttu-id="30a18-140">Definizioni dei membri</span><span class="sxs-lookup"><span data-stu-id="30a18-140">Member Definitions</span></span>

<span data-ttu-id="30a18-141">I tipi possono definire membri per l'utilizzo di XAML.</span><span class="sxs-lookup"><span data-stu-id="30a18-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="30a18-142">È possibile che i tipi definiscano i membri che sono utilizzabili in XAML anche se il tipo specifico non è utilizzabile da XAML.</span><span class="sxs-lookup"><span data-stu-id="30a18-142">It's possible for types to define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="30a18-143">Questa operazione è possibile a causa dell'ereditarietà CLR.</span><span class="sxs-lookup"><span data-stu-id="30a18-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="30a18-144">Purché un tipo che eredita il membro supporti l'utilizzo di XAML come tipo e il membro supporti l'utilizzo di XAML per il tipo sottostante o disponga di una sintassi XAML nativa disponibile, tale membro è utilizzabile da XAML.</span><span class="sxs-lookup"><span data-stu-id="30a18-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>

### <a name="properties"></a><span data-ttu-id="30a18-145">Proprietà</span><span class="sxs-lookup"><span data-stu-id="30a18-145">Properties</span></span>

<span data-ttu-id="30a18-146">Se si definiscono le proprietà come proprietà CLR pubblica usando i tipici `get` modelli CLR e della funzione di accesso e la parola di base relativa alla `set` lingua appropriata, il sistema di tipi XAML può segnalare la proprietà come membro con le informazioni appropriate fornite per le <xref:System.Xaml.XamlMember> proprietà, ad esempio <xref:System.Xaml.XamlMember.IsReadPublic%2A> e <xref:System.Xaml.XamlMember.IsWritePublic%2A> .</span><span class="sxs-lookup"><span data-stu-id="30a18-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>

<span data-ttu-id="30a18-147">Le proprietà specifiche possono abilitare una sintassi del testo applicando <xref:System.ComponentModel.TypeConverterAttribute> .</span><span class="sxs-lookup"><span data-stu-id="30a18-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="30a18-148">Per altre informazioni, vedere [convertitori di tipi ed estensioni di markup per XAML](type-converters-and-markup-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="30a18-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="30a18-149">In assenza di una sintassi di testo o di una conversione XAML nativa e in assenza di ulteriori riferimenti indiretti, ad esempio l'utilizzo di un'estensione di markup, il tipo di una proprietà ( <xref:System.Xaml.XamlMember.TargetType%2A> nel sistema di tipi XAML) deve essere in grado di restituire un'istanza di a un writer di oggetti XAML gestendo il tipo di destinazione come tipo CLR.</span><span class="sxs-lookup"><span data-stu-id="30a18-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>

<span data-ttu-id="30a18-150">Se si usa XAML 2009, è possibile usare l' [estensione di markup x:Reference](xreference-markup-extension.md) per fornire valori se le considerazioni precedenti non vengono soddisfatte. Tuttavia, si tratta di un problema di utilizzo maggiore rispetto a un problema di definizione del tipo.</span><span class="sxs-lookup"><span data-stu-id="30a18-150">If using XAML 2009, [x:Reference Markup Extension](xreference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>

### <a name="events"></a><span data-ttu-id="30a18-151">Eventi</span><span class="sxs-lookup"><span data-stu-id="30a18-151">Events</span></span>

<span data-ttu-id="30a18-152">Se si definiscono gli eventi come un evento CLR pubblico, il sistema di tipi XAML può segnalare l'evento come membro di <xref:System.Xaml.XamlMember.IsEvent%2A> come `true` .</span><span class="sxs-lookup"><span data-stu-id="30a18-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="30a18-153">Il cablaggio dei gestori di eventi non rientra nell'ambito delle funzionalità dei servizi XAML .NET; il cablaggio viene lasciato a Framework e implementazioni specifici.</span><span class="sxs-lookup"><span data-stu-id="30a18-153">Wiring the event handlers is not within the scope of .NET XAML Services capabilities; wiring is left to specific frameworks and implementations.</span></span>

### <a name="methods"></a><span data-ttu-id="30a18-154">Metodi</span><span class="sxs-lookup"><span data-stu-id="30a18-154">Methods</span></span>

<span data-ttu-id="30a18-155">Il codice inline per i metodi non è una funzionalità XAML predefinita.</span><span class="sxs-lookup"><span data-stu-id="30a18-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="30a18-156">Nella maggior parte dei casi, non si fa direttamente riferimento ai membri del metodo da XAML e il ruolo dei metodi in XAML è solo per fornire supporto per modelli XAML specifici.</span><span class="sxs-lookup"><span data-stu-id="30a18-156">In most cases, you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="30a18-157">la [direttiva x:FactoryMethod](xfactorymethod-directive.md) è un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="30a18-157">[x:FactoryMethod Directive](xfactorymethod-directive.md) is an exception.</span></span>

### <a name="fields"></a><span data-ttu-id="30a18-158">Campi</span><span class="sxs-lookup"><span data-stu-id="30a18-158">Fields</span></span>

<span data-ttu-id="30a18-159">Le linee guida di progettazione CLR scoraggiano i campi non statici.</span><span class="sxs-lookup"><span data-stu-id="30a18-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="30a18-160">Per i campi statici è possibile accedere ai valori dei campi statici solo tramite l' [estensione di markup x:static](xstatic-markup-extension.md); in questo caso non si esegue alcuna operazione speciale nella definizione CLR per esporre un campo per gli utilizzi di [x:static](xstatic-markup-extension.md) .</span><span class="sxs-lookup"><span data-stu-id="30a18-160">For static fields, you can access static field values only through [x:Static Markup Extension](xstatic-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](xstatic-markup-extension.md) usages.</span></span>

## <a name="attachable-members"></a><span data-ttu-id="30a18-161">Membri collegati</span><span class="sxs-lookup"><span data-stu-id="30a18-161">Attachable Members</span></span>

<span data-ttu-id="30a18-162">I membri collegati vengono esposti a XAML tramite un modello di metodo della funzione di accesso su un tipo di definizione.</span><span class="sxs-lookup"><span data-stu-id="30a18-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="30a18-163">Non è necessario che il tipo di definizione stesso sia utilizzabile in XAML come oggetto.</span><span class="sxs-lookup"><span data-stu-id="30a18-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="30a18-164">In realtà, un modello comune consiste nel dichiarare una classe del servizio il cui ruolo deve essere il proprietario del membro collegabile e implementare i comportamenti correlati, ma non servire nessun'altra funzione, ad esempio una rappresentazione dell'interfaccia utente.</span><span class="sxs-lookup"><span data-stu-id="30a18-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="30a18-165">Per le sezioni seguenti, il segnaposto *PropertyName* rappresenta il nome del membro collegabile.</span><span class="sxs-lookup"><span data-stu-id="30a18-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="30a18-166">Tale nome deve essere valido nella [Grammatica XamlName](xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="30a18-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>

<span data-ttu-id="30a18-167">Prestare attenzione ai conflitti di nomi tra questi modelli e altri metodi di un tipo.</span><span class="sxs-lookup"><span data-stu-id="30a18-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="30a18-168">Se esiste un membro che corrisponde a uno dei modelli, può essere interpretato come un percorso di utilizzo del membro associabile da un processore XAML anche se non si tratta di un'intenzione.</span><span class="sxs-lookup"><span data-stu-id="30a18-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>

#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="30a18-169">Funzione di accesso GetPropertyName</span><span class="sxs-lookup"><span data-stu-id="30a18-169">The GetPropertyName Accessor</span></span>

<span data-ttu-id="30a18-170">La firma per la `GetPropertyName` funzione di accesso deve essere:</span><span class="sxs-lookup"><span data-stu-id="30a18-170">The signature for the `GetPropertyName` accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="30a18-171">L'oggetto `target` può essere specificato come tipo più specifico nell'implementazione.</span><span class="sxs-lookup"><span data-stu-id="30a18-171">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="30a18-172">Questa operazione può essere utilizzata per definire l'ambito dell'utilizzo del membro collegabile; gli utilizzi al di fuori dell'ambito previsto genereranno eccezioni cast non valide che vengono quindi rilevate da un errore di analisi XAML.</span><span class="sxs-lookup"><span data-stu-id="30a18-172">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="30a18-173">Il nome del parametro `target` non è un requisito, ma è denominato `target` per convenzione nella maggior parte delle implementazioni.</span><span class="sxs-lookup"><span data-stu-id="30a18-173">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>

- <span data-ttu-id="30a18-174">Il valore restituito può essere specificato come tipo più specifico nell'implementazione.</span><span class="sxs-lookup"><span data-stu-id="30a18-174">The return value can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="30a18-175">Per supportare una <xref:System.ComponentModel.TypeConverter> sintassi del testo abilitata per l'utilizzo dell'attributo del membro collegabile, applicare <xref:System.ComponentModel.TypeConverterAttribute> alla `GetPropertyName` funzione di accesso.</span><span class="sxs-lookup"><span data-stu-id="30a18-175">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `GetPropertyName` accessor.</span></span> <span data-ttu-id="30a18-176">L'applicazione di al `get` anziché di `set` può sembrare non intuitiva. Tuttavia, questa convenzione può supportare il concetto di membri di sola lettura che sono serializzabili, che risulta utile negli scenari di progettazione.</span><span class="sxs-lookup"><span data-stu-id="30a18-176">Applying to the `get` instead of the `set` may seem non-intuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>

#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="30a18-177">Funzione di accesso SetPropertyName</span><span class="sxs-lookup"><span data-stu-id="30a18-177">The SetPropertyName Accessor</span></span>

<span data-ttu-id="30a18-178">La firma per la `SetPropertyName` funzione di accesso deve essere:</span><span class="sxs-lookup"><span data-stu-id="30a18-178">The signature for the `SetPropertyName` accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="30a18-179">L' `target` oggetto può essere specificato come tipo più specifico nell'implementazione, con la stessa logica e le stesse conseguenze descritte nella sezione precedente.</span><span class="sxs-lookup"><span data-stu-id="30a18-179">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>

- <span data-ttu-id="30a18-180">L'oggetto `value` può essere specificato come tipo più specifico nell'implementazione.</span><span class="sxs-lookup"><span data-stu-id="30a18-180">The `value` object can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="30a18-181">Tenere presente che il valore di questo metodo è l'input proveniente dall'utilizzo di XAML, in genere in formato attributo.</span><span class="sxs-lookup"><span data-stu-id="30a18-181">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="30a18-182">Dal form dell'attributo è necessario il supporto del convertitore di valori per una sintassi di testo e l'attributo sulla `GetPropertyName` funzione di accesso s.</span><span class="sxs-lookup"><span data-stu-id="30a18-182">From attribute form there must be value converter support for a text syntax, and you attribute on the `GetPropertyName`s accessor.</span></span>

### <a name="attachable-member-stores"></a><span data-ttu-id="30a18-183">Archivi membri collegabili</span><span class="sxs-lookup"><span data-stu-id="30a18-183">Attachable Member Stores</span></span>

<span data-ttu-id="30a18-184">I metodi delle funzioni di accesso non sono in genere sufficienti per fornire un mezzo per inserire i valori dei membri associabili in un oggetto grafico o per recuperare i valori dall'oggetto grafico e serializzarli in modo corretto.</span><span class="sxs-lookup"><span data-stu-id="30a18-184">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="30a18-185">Per fornire questa funzionalità, gli `target` oggetti nelle firme delle funzioni di accesso precedenti devono essere in grado di archiviare i valori.</span><span class="sxs-lookup"><span data-stu-id="30a18-185">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="30a18-186">Il meccanismo di archiviazione deve essere coerente con il principio del membro associabile che il membro è associabile alle destinazioni in cui il membro associabile non è presente nell'elenco dei membri.</span><span class="sxs-lookup"><span data-stu-id="30a18-186">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="30a18-187">I servizi XAML di .NET forniscono una tecnica di implementazione per gli archivi membri collegabili tramite le API <xref:System.Xaml.IAttachedPropertyStore> e <xref:System.Xaml.AttachablePropertyServices> .</span><span class="sxs-lookup"><span data-stu-id="30a18-187">.NET XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="30a18-188"><xref:System.Xaml.IAttachedPropertyStore> viene usato dai writer XAML per individuare l'implementazione dell'archivio e deve essere implementato nel tipo che rappresenta l'oggetto `target` delle funzioni di accesso.</span><span class="sxs-lookup"><span data-stu-id="30a18-188"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="30a18-189">Le <xref:System.Xaml.AttachablePropertyServices> API statiche vengono utilizzate all'interno del corpo delle funzioni di accesso e fanno riferimento al membro collegabile in base al relativo <xref:System.Xaml.AttachableMemberIdentifier> .</span><span class="sxs-lookup"><span data-stu-id="30a18-189">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>

## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="30a18-190">XAML-Related gli attributi CLR</span><span class="sxs-lookup"><span data-stu-id="30a18-190">XAML-Related CLR Attributes</span></span>

<span data-ttu-id="30a18-191">Attribuire correttamente i tipi, i membri e gli assembly è importante per segnalare le informazioni del sistema di tipi XAML ai servizi XAML .NET.</span><span class="sxs-lookup"><span data-stu-id="30a18-191">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET XAML Services.</span></span> <span data-ttu-id="30a18-192">La creazione di report delle informazioni sul sistema di tipi XAML è pertinente se si verifica una delle situazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="30a18-192">Reporting XAML type system information is relevant if either of the following situations apply:</span></span>

- <span data-ttu-id="30a18-193">Si intende usare i tipi con i sistemi XAML basati direttamente sui reader XAML dei servizi XAML .NET e sui writer XAML.</span><span class="sxs-lookup"><span data-stu-id="30a18-193">You intend your types for use with XAML systems that are directly based on .NET XAML Services XAML readers and XAML writers.</span></span>
- <span data-ttu-id="30a18-194">Si definisce o si usa un Framework di utilizzo di XAML basato su tali reader XAML e writer XAML.</span><span class="sxs-lookup"><span data-stu-id="30a18-194">You define or use a XAML-utilizing framework that's based on those XAML readers and XAML writers.</span></span>

<span data-ttu-id="30a18-195">Per un elenco di ogni attributo correlato a XAML pertinente per il supporto XAML dei tipi personalizzati, vedere [attributi CLR correlati a XAML per tipi e librerie personalizzati](clr-attributes-with-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="30a18-195">For a listing of each XAML-related attribute that's relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](clr-attributes-with-custom-types-and-libraries.md).</span></span>

## <a name="usage"></a><span data-ttu-id="30a18-196">Utilizzo</span><span class="sxs-lookup"><span data-stu-id="30a18-196">Usage</span></span>

<span data-ttu-id="30a18-197">Per l'utilizzo di tipi personalizzati è necessario che l'autore del markup debba eseguire il mapping di un prefisso per l'assembly e lo spazio dei nomi CLR che contiene il tipo personalizzato.</span><span class="sxs-lookup"><span data-stu-id="30a18-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="30a18-198">Questa procedura non è documentata in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="30a18-198">This procedure is not documented in this topic.</span></span>

## <a name="access-level"></a><span data-ttu-id="30a18-199">Livello di accesso</span><span class="sxs-lookup"><span data-stu-id="30a18-199">Access Level</span></span>

<span data-ttu-id="30a18-200">XAML fornisce un mezzo per caricare e creare istanze di tipi che hanno un `internal` livello di accesso.</span><span class="sxs-lookup"><span data-stu-id="30a18-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="30a18-201">Questa funzionalità viene fornita in modo che il codice utente possa definire i propri tipi e quindi creare un'istanza di tali classi da markup che fa anche parte dello stesso ambito del codice utente.</span><span class="sxs-lookup"><span data-stu-id="30a18-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>

<span data-ttu-id="30a18-202">Un esempio di WPF è quando il codice utente definisce un oggetto <xref:System.Windows.Controls.UserControl> che viene utilizzato come metodo per effettuare il refactoring di un comportamento dell'interfaccia utente, ma non come parte di un meccanismo di estensione possibile che può essere implicito dichiarando la classe di supporto con il `public` livello di accesso.</span><span class="sxs-lookup"><span data-stu-id="30a18-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="30a18-203">Tale oggetto <xref:System.Windows.Controls.UserControl> può essere dichiarato con `internal` accesso se il codice di supporto viene compilato nello stesso assembly da cui viene fatto riferimento come tipo XAML.</span><span class="sxs-lookup"><span data-stu-id="30a18-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>

<span data-ttu-id="30a18-204">Per un'applicazione che carica XAML con attendibilità totale e USA <xref:System.Xaml.XamlObjectWriter> , è sempre abilitato il caricamento delle classi con il `internal` livello di accesso.</span><span class="sxs-lookup"><span data-stu-id="30a18-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>

<span data-ttu-id="30a18-205">Per un'applicazione che carica XAML con attendibilità parziale, è possibile controllare le caratteristiche del livello di accesso tramite l' <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span><span class="sxs-lookup"><span data-stu-id="30a18-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="30a18-206">Inoltre, i meccanismi di rinvio, ad esempio il sistema di modelli WPF, devono essere in grado di propagare le autorizzazioni del livello di accesso e conservarle per le valutazioni del tempo di esecuzione finali; Questa operazione viene gestita internamente passando le <xref:System.Xaml.Permissions.XamlAccessLevel> informazioni.</span><span class="sxs-lookup"><span data-stu-id="30a18-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>

### <a name="wpf-implementation"></a><span data-ttu-id="30a18-207">Implementazione WPF</span><span class="sxs-lookup"><span data-stu-id="30a18-207">WPF Implementation</span></span>

<span data-ttu-id="30a18-208">XAML WPF usa un modello di accesso parzialmente attendibile in cui se BAML viene caricato con attendibilità parziale, l'accesso è limitato a <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> per l'assembly che è l'origine BAML.</span><span class="sxs-lookup"><span data-stu-id="30a18-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="30a18-209">Per il rinvio, WPF USA <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> come meccanismo per passare le informazioni sul livello di accesso.</span><span class="sxs-lookup"><span data-stu-id="30a18-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>

<span data-ttu-id="30a18-210">Nella terminologia XAML di WPF, un *tipo interno* è un tipo definito dallo stesso assembly che include anche il codice XAML di riferimento.</span><span class="sxs-lookup"><span data-stu-id="30a18-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="30a18-211">Questo tipo può essere mappato tramite uno spazio dei nomi XAML che omette intenzionalmente la parte assembly = di un mapping, ad esempio `xmlns:local="clr-namespace:WPFApplication1"` .</span><span class="sxs-lookup"><span data-stu-id="30a18-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span> <span data-ttu-id="30a18-212">Se BAML fa riferimento a un tipo interno e a tale tipo è associato un `internal` livello di accesso, viene generata una `GeneratedInternalTypeHelper` classe per l'assembly.</span><span class="sxs-lookup"><span data-stu-id="30a18-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="30a18-213">Se si desidera evitare `GeneratedInternalTypeHelper` , è necessario utilizzare `public` il livello di accesso oppure eseguire il factoring della classe pertinente in un assembly separato e rendere dipendente tale assembly.</span><span class="sxs-lookup"><span data-stu-id="30a18-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>

## <a name="see-also"></a><span data-ttu-id="30a18-214">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="30a18-214">See also</span></span>

- [<span data-ttu-id="30a18-215">Attributi CLR correlati a XAML per tipi e librerie personalizzati</span><span class="sxs-lookup"><span data-stu-id="30a18-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](clr-attributes-with-custom-types-and-libraries.md)
- [<span data-ttu-id="30a18-216">Servizi XAML</span><span class="sxs-lookup"><span data-stu-id="30a18-216">XAML Services</span></span>](/dotnet/api/)
